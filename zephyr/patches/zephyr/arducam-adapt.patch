diff --git a/drivers/video/arducam_mega.c b/drivers/video/arducam_mega.c
index e790d88b037..a06e78a3340 100644
--- a/drivers/video/arducam_mega.c
+++ b/drivers/video/arducam_mega.c
@@ -10,11 +10,13 @@
 
 #include <zephyr/device.h>
 #include <zephyr/drivers/video.h>
+#include <zephyr/drivers/video-controls.h>
 #include <zephyr/drivers/spi.h>
 
-#include <zephyr/logging/log.h>
-LOG_MODULE_REGISTER(mega_camera);
+#include "video_ctrls.h"
 
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(mega_camera, LOG_LEVEL_INF);
 
 #define ARDUCHIP_FIFO   0x04 /* FIFO and I2C control */
 #define ARDUCHIP_FIFO_2 0x07 /* FIFO and I2C control */
@@ -75,7 +77,7 @@ LOG_MODULE_REGISTER(mega_camera);
 #define CTR_GAIN         0X00
 
 #define AC_STACK_SIZE 4096
-#define AC_PRIORITY 5
+#define AC_PRIORITY   5
 
 K_THREAD_STACK_DEFINE(ac_stack_area, AC_STACK_SIZE);
 
@@ -96,8 +98,28 @@ struct arducam_mega_config {
 	struct spi_dt_spec bus;
 };
 
+struct arducam_mega_ctrls {
+	struct {
+		struct video_ctrl auto_exposure;
+		struct video_ctrl exposure;
+	};
+	struct {
+		struct video_ctrl auto_gain;
+		struct video_ctrl gain;
+	};
+	struct video_ctrl brightness;
+	struct video_ctrl saturation;
+	struct {
+		struct video_ctrl auto_white_balance;
+		struct video_ctrl white_balance;
+	};
+	struct video_ctrl contrast;
+	struct video_ctrl jpeq_quality;
+};
+
 struct arducam_mega_data {
 	const struct device *dev;
+	// struct arducam_mega_ctrls ctrls;
 	struct video_format fmt;
 	struct k_fifo fifo_in;
 	struct k_fifo fifo_out;
@@ -441,7 +463,7 @@ static int arducam_mega_set_white_bal_enable(const struct device *dev, int enabl
 	return ret;
 }
 
-static int arducam_mega_set_white_bal(const struct device *dev, enum MEGA_EV_LEVEL level)
+static int arducam_mega_set_white_bal(const struct device *dev, enum MEGA_WHITE_BALANCE level)
 {
 	int ret = 0;
 	const struct arducam_mega_config *cfg = dev->config;
@@ -451,7 +473,7 @@ static int arducam_mega_set_white_bal(const struct device *dev, enum MEGA_EV_LEV
 	ret |= arducam_mega_write_reg(&cfg->bus, CAM_REG_WHITEBALANCE_CONTROL, level);
 
 	if (ret == -1) {
-		LOG_ERR("Failed to set contrast level %d", level);
+		LOG_ERR("Failed to set white balance level %d", level);
 	}
 
 	return ret;
@@ -477,7 +499,7 @@ static int arducam_mega_set_gain_enable(const struct device *dev, int enable)
 	return ret;
 }
 
-static int arducam_mega_set_lowpower_enable(const struct device *dev, int enable)
+int arducam_mega_set_lowpower_enable(const struct device *dev, int enable)
 {
 	int ret = 0;
 	const struct arducam_mega_config *cfg = dev->config;
@@ -631,8 +653,7 @@ static int arducam_mega_check_connection(const struct device *dev)
 	return ret;
 }
 
-static int arducam_mega_set_fmt(const struct device *dev, enum video_endpoint_id ep,
-				struct video_format *fmt)
+static int arducam_mega_set_fmt(const struct device *dev, struct video_format *fmt)
 {
 	struct arducam_mega_data *drv_data = dev->data;
 	uint16_t width, height;
@@ -676,8 +697,7 @@ static int arducam_mega_set_fmt(const struct device *dev, enum video_endpoint_id
 	return -ENOTSUP;
 }
 
-static int arducam_mega_get_fmt(const struct device *dev, enum video_endpoint_id ep,
-				struct video_format *fmt)
+static int arducam_mega_get_fmt(const struct device *dev, struct video_format *fmt)
 {
 	struct arducam_mega_data *drv_data = dev->data;
 
@@ -704,7 +724,8 @@ static int arducam_mega_stream_start(const struct device *dev)
 	drv_data->stream_on = 1;
 	drv_data->fifo_length = 0;
 
-	k_timer_start(&drv_data->stream_schedule_timer, K_MSEC(30), K_MSEC(30));
+	// k_timer_start(&drv_data->stream_schedule_timer, K_MSEC(30), K_MSEC(30));
+	k_work_submit_to_queue(&ac_work_q, &drv_data->buf_work);
 
 	return 0;
 }
@@ -720,7 +741,13 @@ static int arducam_mega_stream_stop(const struct device *dev)
 	return 0;
 }
 
-static int arducam_mega_flush(const struct device *dev, enum video_endpoint_id ep, bool cancel)
+static int arducam_mega_set_stream(const struct device *dev, bool enable, enum video_buf_type type)
+{
+	ARG_UNUSED(type);
+	return enable ? arducam_mega_stream_start(dev) : arducam_mega_stream_stop(dev);
+}
+
+static int arducam_mega_flush(const struct device *dev, bool cancel)
 {
 	struct arducam_mega_data *drv_data = dev->data;
 	struct video_buffer *vbuf;
@@ -811,7 +838,6 @@ static void __buffer_work(struct k_work *work)
 
 	vbuf = k_fifo_get(&drv_data->fifo_in, K_FOREVER);
 
-
 	if (vbuf == NULL) {
 		return;
 	}
@@ -837,98 +863,98 @@ static void __buffer_work(struct k_work *work)
 	k_yield();
 }
 
-static int arducam_mega_enqueue(const struct device *dev, enum video_endpoint_id ep,
-				struct video_buffer *vbuf)
+static int arducam_mega_enqueue(const struct device *dev, struct video_buffer *vbuf)
 {
 	struct arducam_mega_data *data = dev->data;
 
-	if (ep != VIDEO_EP_OUT) {
-		return -EINVAL;
-	}
+	// if (vbuf->type != VIDEO_BUF_TYPE_OUTPUT) {
+	// 	return -EINVAL;
+	// }
 	k_fifo_put(&data->fifo_in, vbuf);
 
-	LOG_DBG("enqueue buffer %p", vbuf->buffer);
+	LOG_DBG("enqueue buffer %p", (void *)vbuf->buffer);
 
 	return 0;
 }
 
-static int arducam_mega_dequeue(const struct device *dev, enum video_endpoint_id ep,
-				struct video_buffer **vbuf, k_timeout_t timeout)
+static int arducam_mega_dequeue(const struct device *dev, struct video_buffer **vbuf,
+				k_timeout_t timeout)
 {
 	struct arducam_mega_data *data = dev->data;
 
-	if (ep != VIDEO_EP_OUT) {
-		return -EINVAL;
-	}
-
 	*vbuf = k_fifo_get(&data->fifo_out, timeout);
 
-	LOG_DBG("dequeue buffer %p", (*vbuf)->buffer);
+	// if ((*vbuf)->type != VIDEO_BUF_TYPE_OUTPUT) {
+	// 	return -EINVAL;
+	// }
 
 	if (*vbuf == NULL) {
 		return -EAGAIN;
 	}
 
+	LOG_DBG("dequeue buffer %p", (void *)(*vbuf)->buffer);
+
 	return 0;
 }
 
-static int arducam_mega_get_caps(const struct device *dev, enum video_endpoint_id ep,
-				 struct video_caps *caps)
+static int arducam_mega_get_caps(const struct device *dev, struct video_caps *caps)
 {
 	caps->format_caps = fmts;
 	return 0;
 }
 
-static int arducam_mega_set_ctrl(const struct device *dev, unsigned int cid, void *value)
+static int arducam_mega_set_ctrl(const struct device *dev, struct video_control *control)
 {
 	int ret = 0;
 
-	switch (cid) {
-	case VIDEO_CID_CAMERA_EXPOSURE_AUTO:
-		ret |= arducam_mega_set_exposure_enable(dev, *(uint8_t *)value);
+	switch (control->id) {
+	case VIDEO_CID_EXPOSURE_AUTO:
+		ret |= arducam_mega_set_exposure_enable(dev, *(uint8_t *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_EXPOSURE:
-		ret |= arducam_mega_set_exposure(dev, *(uint32_t *)value);
+	case VIDEO_CID_EXPOSURE:
+		ret |= arducam_mega_set_exposure(dev, *(uint32_t *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_GAIN_AUTO:
-		ret |= arducam_mega_set_gain_enable(dev, *(uint8_t *)value);
+	case VIDEO_CID_AUTOGAIN:
+		ret |= arducam_mega_set_gain_enable(dev, *(uint8_t *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_GAIN:
-		ret |= arducam_mega_set_gain(dev, *(uint16_t *)value);
+	case VIDEO_CID_GAIN:
+		ret |= arducam_mega_set_gain(dev, *(uint16_t *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_BRIGHTNESS:
-		ret |= arducam_mega_set_brightness(dev, *(enum MEGA_BRIGHTNESS_LEVEL *)value);
+	case VIDEO_CID_BRIGHTNESS:
+		ret |= arducam_mega_set_brightness(dev,
+						   *(enum MEGA_BRIGHTNESS_LEVEL *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_SATURATION:
-		ret |= arducam_mega_set_saturation(dev, *(enum MEGA_SATURATION_LEVEL *)value);
+	case VIDEO_CID_SATURATION:
+		ret |= arducam_mega_set_saturation(dev,
+						   *(enum MEGA_SATURATION_LEVEL *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_WHITE_BAL_AUTO:
-		ret |= arducam_mega_set_white_bal_enable(dev, *(uint8_t *)value);
+	case VIDEO_CID_AUTO_WHITE_BALANCE:
+		ret |= arducam_mega_set_white_bal_enable(dev, *(uint8_t *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_WHITE_BAL:
-		ret |= arducam_mega_set_white_bal(dev, *(enum MEGA_WHITE_BALANCE *)value);
+	case VIDEO_CID_WHITE_BALANCE_TEMPERATURE:
+		ret |= arducam_mega_set_white_bal(dev, *(enum MEGA_WHITE_BALANCE *)control->val);
 		break;
-	case VIDEO_CID_CAMERA_CONTRAST:
-		ret |= arducam_mega_set_contrast(dev, *(enum MEGA_CONTRAST_LEVEL *)value);
+	case VIDEO_CID_CONTRAST:
+		ret |= arducam_mega_set_contrast(dev, *(enum MEGA_CONTRAST_LEVEL *)control->val);
 		break;
 	case VIDEO_CID_JPEG_COMPRESSION_QUALITY:
-		ret |= arducam_mega_set_JPEG_quality(dev, *(enum MEGA_IMAGE_QUALITY *)value);
+		ret |= arducam_mega_set_JPEG_quality(dev, *(enum MEGA_IMAGE_QUALITY *)control->val);
 		break;
 	case VIDEO_CID_ARDUCAM_EV:
-		ret |= arducam_mega_set_EV(dev, *(enum MEGA_EV_LEVEL *)value);
+		ret |= arducam_mega_set_EV(dev, *(enum MEGA_EV_LEVEL *)control->val);
 		break;
-	case VIDEO_CID_ARDUCAM_SHARPNESS:
-		ret |= arducam_mega_set_sharpness(dev, *(enum MEGA_SHARPNESS_LEVEL *)value);
+	case VIDEO_CID_SHARPNESS:
+		ret |= arducam_mega_set_sharpness(dev, *(enum MEGA_SHARPNESS_LEVEL *)control->val);
 		break;
 	case VIDEO_CID_ARDUCAM_COLOR_FX:
-		ret |= arducam_mega_set_special_effects(dev, *(enum MEGA_COLOR_FX *)value);
+		ret |= arducam_mega_set_special_effects(dev, *(enum MEGA_COLOR_FX *)control->val);
 		break;
 	case VIDEO_CID_ARDUCAM_RESET:
 		ret |= arducam_mega_soft_reset(dev);
 		ret |= arducam_mega_check_connection(dev);
 		break;
 	case VIDEO_CID_ARDUCAM_LOWPOWER:
-		ret |= arducam_mega_set_lowpower_enable(dev, *(uint8_t *)value);
+		ret |= arducam_mega_set_lowpower_enable(dev, *(uint8_t *)control->val);
 		break;
 	default:
 		return -ENOTSUP;
@@ -964,12 +990,11 @@ static int arducam_mega_get_ctrl(const struct device *dev, unsigned int cid, voi
 static const struct video_driver_api arducam_mega_driver_api = {
 	.set_format = arducam_mega_set_fmt,
 	.get_format = arducam_mega_get_fmt,
-	.stream_start = arducam_mega_stream_start,
-	.stream_stop = arducam_mega_stream_stop,
+	.set_stream = arducam_mega_set_stream,
 	.get_caps = arducam_mega_get_caps,
 	.flush = arducam_mega_flush,
-	.set_ctrl = arducam_mega_set_ctrl,
-	.get_ctrl = arducam_mega_get_ctrl,
+	// .set_ctrl = arducam_mega_set_ctrl,
+	// .get_ctrl = arducam_mega_get_ctrl,
 	.enqueue = arducam_mega_enqueue,
 	.dequeue = arducam_mega_dequeue,
 };
@@ -992,7 +1017,7 @@ static int arducam_mega_init(const struct device *dev)
 	k_fifo_init(&drv_data->fifo_out);
 	k_work_queue_init(&ac_work_q);
 	k_work_queue_start(&ac_work_q, ac_stack_area, K_THREAD_STACK_SIZEOF(ac_stack_area),
-		AC_PRIORITY, NULL);
+			   AC_PRIORITY, NULL);
 
 	k_timer_init(&drv_data->stream_schedule_timer, on_stream_schedule_timer_func, NULL);
 	drv_data->stream_schedule_timer.user_data = (void *)drv_data;
@@ -1017,11 +1042,12 @@ static int arducam_mega_init(const struct device *dev)
 		drv_data->ver.day, drv_data->ver.version);
 
 	/* set default/init format 96x96 RGB565 */
+	fmt.type = VIDEO_BUF_TYPE_OUTPUT;
 	fmt.pixelformat = VIDEO_PIX_FMT_RGB565;
 	fmt.width = 96;
 	fmt.height = 96;
 	fmt.pitch = 96 * 2;
-	ret = arducam_mega_set_fmt(dev, VIDEO_EP_OUT, &fmt);
+	ret = arducam_mega_set_fmt(dev, &fmt);
 	if (ret) {
 		LOG_ERR("Unable to configure default format");
 		return -EIO;
diff --git a/samples/drivers/video/arducam_mega_full-featured/boards/nrf54lm20dk_nrf54lm20a_cpuapp.overlay b/samples/drivers/video/arducam_mega_full-featured/boards/nrf54lm20dk_nrf54lm20a_cpuapp.overlay
new file mode 100644
index 00000000000..4b384434cd8
--- /dev/null
+++ b/samples/drivers/video/arducam_mega_full-featured/boards/nrf54lm20dk_nrf54lm20a_cpuapp.overlay
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) 2025 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
+ */
+
+/ {
+	chosen {
+		zephyr,console = &uart30;
+	};
+};
+
+&gpio3 {
+	status = "okay";
+};
+
+&uart30 {
+	status = "okay";
+};
+
+&pinctrl {
+	spi22_default: spi22_default {
+		group1 {
+			psels = <NRF_PSEL(SPIM_SCK, 3, 4)>,
+			        <NRF_PSEL(SPIM_MISO, 3, 5)>,
+			        <NRF_PSEL(SPIM_MOSI, 3, 6)>;
+			bias-pull-down;
+		};
+	};
+
+	spi22_sleep: spi22_sleep {
+		group1 {
+			psels = <NRF_PSEL(SPIM_SCK, 3, 4)>,
+			        <NRF_PSEL(SPIM_MISO, 3, 5)>,
+			        <NRF_PSEL(SPIM_MOSI, 3, 6)>;
+			bias-pull-down;
+			low-power-enable;
+		};
+	};
+};
+
+&spi22 {
+	compatible = "nordic,nrf-spim";
+	status = "okay";
+	pinctrl-0 = <&spi22_default>;
+	pinctrl-1 = <&spi22_sleep>;
+	pinctrl-names = "default", "sleep";
+	overrun-character = <0x00>;
+	zephyr,pm-device-runtime-auto;
+	cs-gpios = <&gpio3 7 GPIO_ACTIVE_LOW>;
+
+	arducam_mega: arducam-mega@0 {
+		compatible = "arducam,mega";
+		reg = <0>;
+		spi-max-frequency = <4000000>;
+		status = "okay";
+	};
+};
diff --git a/samples/drivers/video/arducam_mega_full-featured/prj.conf b/samples/drivers/video/arducam_mega_full-featured/prj.conf
index 8a170d7da69..4acfc883c52 100644
--- a/samples/drivers/video/arducam_mega_full-featured/prj.conf
+++ b/samples/drivers/video/arducam_mega_full-featured/prj.conf
@@ -7,3 +7,9 @@ CONFIG_VIDEO=y
 CONFIG_VIDEO_INIT_PRIORITY=72
 CONFIG_VIDEO_BUFFER_POOL_SZ_MAX=2048
 CONFIG_VIDEO_BUFFER_POOL_NUM_MAX=3
+
+CONFIG_CONSOLE=y
+CONFIG_UART_CONSOLE=y
+CONFIG_LOG_BACKEND_UART=y
+CONFIG_UART_ASYNC_API=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
diff --git a/samples/drivers/video/arducam_mega_full-featured/src/main.c b/samples/drivers/video/arducam_mega_full-featured/src/main.c
index 980a38ef5df..c1ed04a586b 100644
--- a/samples/drivers/video/arducam_mega_full-featured/src/main.c
+++ b/samples/drivers/video/arducam_mega_full-featured/src/main.c
@@ -8,6 +8,7 @@
 #include <zephyr/kernel.h>
 
 #include <zephyr/drivers/video.h>
+#include <zephyr/drivers/video-controls.h>
 #include <zephyr/drivers/video/arducam_mega.h>
 
 #include <zephyr/drivers/uart.h>
@@ -60,7 +61,7 @@ const uint32_t pixel_format_table[] = {
 };
 
 const uint16_t resolution_table[][2] = {
-	{160, 120},  {320, 240},   {640, 480},   {800, 600},   {1280, 720},
+	{96, 96},    {128, 128},   {640, 480},   {800, 600},   {1280, 720},
 	{1280, 960}, {1600, 1200}, {1920, 1080}, {2048, 1536}, {2592, 1944},
 	{96, 96},    {128, 128},   {320, 320},
 };
@@ -75,14 +76,17 @@ int set_mega_resolution(uint8_t sfmt)
 	uint8_t resolution = sfmt & 0x0f;
 	uint8_t pixelformat = (sfmt & 0x70) >> 4;
 
+	LOG_INF("sfmt: %x, res: %u, pix: %u", sfmt, resolution, pixelformat);
+
 	if (resolution > resolution_num || pixelformat > 3) {
 		return -1;
 	}
-	struct video_format fmt = {.width = resolution_table[resolution][0],
+	struct video_format fmt = {.type = VIDEO_BUF_TYPE_OUTPUT,
+				   .width = resolution_table[resolution][0],
 				   .height = resolution_table[resolution][1],
 				   .pixelformat = pixel_format_table[pixelformat - 1]};
 	current_resolution = resolution;
-	return video_set_format(video, VIDEO_EP_OUT, &fmt);
+	return video_set_format(video, &fmt);
 }
 
 void uart_buffer_send(const struct device *dev, uint8_t *buffer, uint32_t length)
@@ -108,9 +112,9 @@ int take_picture(void)
 	int err;
 	enum video_frame_fragmented_status f_status;
 
-	err = video_dequeue(video, VIDEO_EP_OUT, &vbuf, K_FOREVER);
+	err = video_dequeue(video, &vbuf, K_FOREVER);
 	if (err) {
-		LOG_ERR("Unable to dequeue video buf");
+		LOG_ERR("Unable to dequeue video buf (%d)", err);
 		return -1;
 	}
 
@@ -121,14 +125,24 @@ int take_picture(void)
 	uart_buffer_send(console, (uint8_t *)&vbuf->bytesframe, 4);
 	uart_poll_out(console, ((current_resolution & 0x0f) << 4) | 0x01);
 
+	LOG_HEXDUMP_INF(vbuf->buffer, MIN(64, vbuf->bytesused), "dump");
+
+	for (int i = 0; i < 1024; i += 2) {
+		vbuf->buffer[i] &= 0b11111000;
+		vbuf->buffer[i+1] &= 0b00000000;
+	}
+
 	uart_buffer_send(console, vbuf->buffer, vbuf->bytesused);
 
-	video_enqueue(video, VIDEO_EP_OUT, vbuf);
+	vbuf->type = VIDEO_BUF_TYPE_OUTPUT;
+	video_enqueue(video, vbuf);
 	while (f_status == VIDEO_BUF_FRAG) {
-		video_dequeue(video, VIDEO_EP_OUT, &vbuf, K_FOREVER);
+		video_dequeue(video, &vbuf, K_FOREVER);
 		f_status = vbuf->flags;
 		uart_buffer_send(console, vbuf->buffer, vbuf->bytesused);
-		video_enqueue(video, VIDEO_EP_OUT, vbuf);
+
+		vbuf->type = VIDEO_BUF_TYPE_OUTPUT;
+		video_enqueue(video, vbuf);
 	}
 	uart_buffer_send(console, &head_and_tail[3], 2);
 
@@ -144,7 +158,7 @@ void video_preview(void)
 		return;
 	}
 
-	err = video_dequeue(video, VIDEO_EP_OUT, &vbuf, K_FOREVER);
+	err = video_dequeue(video, &vbuf, K_FOREVER);
 	if (err) {
 		LOG_ERR("Unable to dequeue video buf");
 		return;
@@ -153,6 +167,7 @@ void video_preview(void)
 	f_status = vbuf->flags;
 
 	if (capture_flag == 1) {
+		LOG_INF("bytesframe: %d", vbuf->bytesframe);
 		capture_flag = 0;
 		head_and_tail[2] = 0x01;
 		uart_buffer_send(console, &head_and_tail[0], 3);
@@ -167,13 +182,16 @@ void video_preview(void)
 		capture_flag = 1;
 	}
 
-	err = video_enqueue(video, VIDEO_EP_OUT, vbuf);
+	vbuf->type = VIDEO_BUF_TYPE_OUTPUT;
+	err = video_enqueue(video, vbuf);
 	if (err) {
 		LOG_ERR("Unable to requeue video buf");
 		return;
 	}
 }
 
+int arducam_mega_get_info(const struct device *dev, struct arducam_mega_info *info);
+
 int report_mega_info(void)
 {
 	char str_buf[400];
@@ -181,7 +199,7 @@ int report_mega_info(void)
 	char *mega_type;
 	struct arducam_mega_info mega_info;
 
-	video_get_ctrl(video, VIDEO_CID_ARDUCAM_INFO, &mega_info);
+	arducam_mega_get_info(video, &mega_info);
 
 	switch (mega_info.camera_id) {
 	case ARDUCAM_SENSOR_3MP_1:
@@ -224,73 +242,73 @@ uint8_t recv_process(uint8_t *buff)
 	case SET_VIDEO_RESOLUTION:
 		if (preview_on == 0) {
 			set_mega_resolution(buff[1] | 0x10);
-			video_stream_start(video);
+			video_stream_start(video, VIDEO_BUF_TYPE_OUTPUT);
 			capture_flag = 1;
 		}
 		preview_on = 1;
 		break;
-	case SET_BRIGHTNESS:
-		video_set_ctrl(video, VIDEO_CID_CAMERA_BRIGHTNESS, &buff[1]);
-		break;
-	case SET_CONTRAST:
-		video_set_ctrl(video, VIDEO_CID_CAMERA_CONTRAST, &buff[1]);
-		break;
-	case SET_SATURATION:
-		video_set_ctrl(video, VIDEO_CID_CAMERA_SATURATION, &buff[1]);
-		break;
-	case SET_EV:
-		video_set_ctrl(video, VIDEO_CID_ARDUCAM_EV, &buff[1]);
-		break;
-	case SET_WHITEBALANCE:
-		video_set_ctrl(video, VIDEO_CID_CAMERA_WHITE_BAL, &buff[1]);
-		break;
-	case SET_SPECIAL_EFFECTS:
-		video_set_ctrl(video, VIDEO_CID_ARDUCAM_COLOR_FX, &buff[1]);
-		break;
-	case SET_EXPOSURE_GAIN_ENABLE:
-		video_set_ctrl(video, VIDEO_CID_CAMERA_EXPOSURE_AUTO, &buff[1]);
-		video_set_ctrl(video, VIDEO_CID_CAMERA_GAIN_AUTO, &buff[1]);
-	case SET_WHITE_BALANCE_ENABLE:
-		video_set_ctrl(video, VIDEO_CID_CAMERA_WHITE_BAL_AUTO, &buff[1]);
-		break;
-	case SET_SHARPNESS:
-		video_set_ctrl(video, VIDEO_CID_ARDUCAM_SHARPNESS, &buff[1]);
-		break;
-	case SET_MANUAL_GAIN:
-		uint16_t gain_value = (buff[1] << 8) | buff[2];
-
-		video_set_ctrl(video, VIDEO_CID_CAMERA_GAIN, &gain_value);
-		break;
-	case SET_MANUAL_EXPOSURE:
-		uint32_t exposure_value = (buff[1] << 16) | (buff[2] << 8) | buff[3];
-
-		video_set_ctrl(video, VIDEO_CID_CAMERA_EXPOSURE, &exposure_value);
-		break;
+	// case SET_BRIGHTNESS:
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_BRIGHTNESS, &buff[1]);
+	// 	break;
+	// case SET_CONTRAST:
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_CONTRAST, &buff[1]);
+	// 	break;
+	// case SET_SATURATION:
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_SATURATION, &buff[1]);
+	// 	break;
+	// case SET_EV:
+	// 	video_set_ctrl(video, VIDEO_CID_ARDUCAM_EV, &buff[1]);
+	// 	break;
+	// case SET_WHITEBALANCE:
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_WHITE_BAL, &buff[1]);
+	// 	break;
+	// case SET_SPECIAL_EFFECTS:
+	// 	video_set_ctrl(video, VIDEO_CID_ARDUCAM_COLOR_FX, &buff[1]);
+	// 	break;
+	// case SET_EXPOSURE_GAIN_ENABLE:
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_EXPOSURE_AUTO, &buff[1]);
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_GAIN_AUTO, &buff[1]);
+	// case SET_WHITE_BALANCE_ENABLE:
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_WHITE_BAL_AUTO, &buff[1]);
+	// 	break;
+	// case SET_SHARPNESS:
+	// 	video_set_ctrl(video, VIDEO_CID_ARDUCAM_SHARPNESS, &buff[1]);
+	// 	break;
+	// case SET_MANUAL_GAIN:
+	// 	uint16_t gain_value = (buff[1] << 8) | buff[2];
+
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_GAIN, &gain_value);
+	// 	break;
+	// case SET_MANUAL_EXPOSURE:
+	// 	uint32_t exposure_value = (buff[1] << 16) | (buff[2] << 8) | buff[3];
+
+	// 	video_set_ctrl(video, VIDEO_CID_CAMERA_EXPOSURE, &exposure_value);
+	// 	break;
 	case GET_CAMERA_INFO:
 		report_mega_info();
 		break;
 	case TAKE_PICTURE:
-		video_stream_start(video);
+		video_stream_start(video, VIDEO_BUF_TYPE_OUTPUT);
 		take_picture();
-		video_stream_stop(video);
+		video_stream_stop(video, VIDEO_BUF_TYPE_OUTPUT);
 		break;
 	case STOP_STREAM:
 		if (preview_on) {
 			uart_buffer_send(console, &head_and_tail[3], 2);
-			video_stream_stop(video);
+			video_stream_stop(video, VIDEO_BUF_TYPE_OUTPUT);
 			set_mega_resolution(take_picture_fmt);
 		}
 		preview_on = 0;
 		break;
-	case RESET_CAMERA:
-		video_set_ctrl(video, VIDEO_CID_ARDUCAM_RESET, NULL);
-		break;
-	case SET_IMAGE_QUALITY:
-		video_set_ctrl(video, VIDEO_CID_JPEG_COMPRESSION_QUALITY, &buff[1]);
-		break;
-	case SET_LOWPOWER_MODE:
-		video_set_ctrl(video, VIDEO_CID_ARDUCAM_LOWPOWER, &buff[1]);
-		break;
+	// case RESET_CAMERA:
+	// 	video_set_ctrl(video, VIDEO_CID_ARDUCAM_RESET, NULL);
+	// 	break;
+	// case SET_IMAGE_QUALITY:
+	// 	video_set_ctrl(video, VIDEO_CID_JPEG_COMPRESSION_QUALITY, &buff[1]);
+	// 	break;
+	// case SET_LOWPOWER_MODE:
+	// 	video_set_ctrl(video, VIDEO_CID_ARDUCAM_LOWPOWER, &buff[1]);
+	// 	break;
 	default:
 		break;
 	}
@@ -309,7 +327,7 @@ int main(void)
 	struct video_buffer *buffers[3];
 	int i = 0;
 
-	console = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
+	console = DEVICE_DT_GET(DT_NODELABEL(uart20));
 	if (!device_is_ready(console)) {
 		LOG_ERR("%s: device not ready.", console->name);
 		return -1;
@@ -317,7 +335,7 @@ int main(void)
 	uart_irq_callback_user_data_set(console, serial_cb, NULL);
 	uart_irq_rx_enable(console);
 
-	video = DEVICE_DT_GET(DT_NODELABEL(arducam_mega0));
+	video = DEVICE_DT_GET(DT_NODELABEL(arducam_mega));
 
 	if (!device_is_ready(video)) {
 		LOG_ERR("Video device %s not ready.", video->name);
@@ -326,12 +344,13 @@ int main(void)
 
 	/* Alloc video buffers and enqueue for capture */
 	for (i = 0; i < ARRAY_SIZE(buffers); i++) {
-		buffers[i] = video_buffer_alloc(1024);
+		buffers[i] = video_buffer_alloc(1024, K_FOREVER);
 		if (buffers[i] == NULL) {
 			LOG_ERR("Unable to alloc video buffer");
 			return -1;
 		}
-		video_enqueue(video, VIDEO_EP_OUT, buffers[i]);
+		buffers[i]->type = VIDEO_BUF_TYPE_OUTPUT;
+		video_enqueue(video, buffers[i]);
 	}
 
 	LOG_INF("Mega star");
